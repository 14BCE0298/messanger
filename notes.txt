1. REST services borrow the below mentioned mechanisms from HTTP :-
    -   Resource based URL's
    -   HTTP methods are used {GET, PUT, POST, DELETE}
    -   Responce responds back with appropriate HTTP status codes.
    -   Responce should have appropriate headers like content-type.

2. The REST Resource URI's are of 2 types
    -   Instance URI - Get details for single Resource. EX - /messages/{messageId}
    -   Collection URI - Get a collection of details. EX - /messages

3. Query parameters can be used for Pagination and Filtering. EX - /messages/{messageId}?results=10&year=2014.

4. When creating a new resource instance we use the POST method with collections URI. EX - /messages

5.  Idempotent methods - GET, PUT, DELETE {Can be repeated}
    Non-Idempotent methods - POST

6. The different error codes classes are mentioned below :-
    -   1XX - Informational
    -   2XX - Success
    -   3XX - Redirection
    -   4XX - Client error
    -   5XX - Server error

7. HATEOAS is a way to provide client link to various resources as a responce to an api call so that no URL creation has to be done at client side.

8. In SOAP services only one API end point is exposed and the request body contains details for what operation is to be performed.

9. According to Richardson Maturity Model below mentioned are the levels of REST service achived :-

    -   Lvl 0 - Using single API endpoint
    -   Lvl 1 - Using resource based URI'service
    -   Lvl 2 - Using HTTP methods {POST, PUT etc}
    -   Lvl 3 - HATEOAS

10. JAX-RS is a set of interfaces and annotations that has api's for REST services. Library classes like jersey or RESTeasy 
implement these interfaces and make sense of the annotations wherever the JAX-RS api's are used. Every JAX-RS Library comes
with a copy of JAX-RS.

11. jaxb is used by java to convert response to XML file.

12. Always have a no-arg constructor whenre turning XML/JSON responce as the associated libraries uses it internally.

13. @QueryParam URL design = http://localhost:8080/messanger/webapi/messages?start=0&size=2

14. Some important params that we can extract from incoming request :-

    -   @MatrixParam    -> Similar as @QueryParam but uses ; to seprate values;
    -   @HeaderParam    -> Get token value sent in header.
    -   @CookieParam    -> Get token value sent in cookie.
    -   @Context        -> This cannot annotate to any datatype but only few selected ones like 'class:UriInfo, HttpHeaders' and 
                           is used to get details about the request without specifying details if you don't know them before hand,
                           like AbsolutePath, ContextPath, QueryParams, Cookies etc

15. Responce object can be returned instead of actual object as Responce class has methods to return any class entity along with
editing HTTP status codes (.status(Status.CREATED)), return an object/value (.entity), sending URI along with status code 201
(.created(new URI("/messanger/webapi/messages/ + message.getId())));

EX - 
@POST
	public Response addMessage(Message message, @Context UriInfo uriInfo) {
		
		Message newMessage = messageService.addMessage(message);
		String newId = String.valueOf(newMessage.getId());
		URI uri = uriInfo.getAbsolutePathBuilder().path(newId).build();
		return Response.created(uri)
				.entity(newMessage)
				.build();
	}

16. A basic exception handlind example for REST calls :-

    //method that may have exception scenario
    public Message getMessage(long id) {                                
            Message message = messages.get(id);
            if (message == null) {
                throw new DataNotFoundException("Message with id " + id + " not found");
            }
            return message;
        }

    public class DataNotFoundException extends RuntimeException {       //Custom exception handling class
	private static final long serialVersionUID = -6328286661536343936L;
	public DataNotFoundException(String message) {
		super(message);
	}

    //Error object Class
    @XmlRootElement
    public class ErrorMessage {

	private String errorMessage;
	private int errorCode;
	private String documentation;
	
	public ErrorMessage() {
		
	}
		
	public ErrorMessage(String errorMessage, int errorCode, String documentation) {
		super();
		this.errorMessage = errorMessage;
		this.errorCode = errorCode;
		this.documentation = documentation;
	}


    // Class to implement and Map exception to responce when thrown
    @Provider //annotation to let jax.rs know that this class exists
    public class DataNotFoundExceptionMapper implements ExceptionMapper<DataNotFoundException> { 

	@Override
	public Response toResponse(DataNotFoundException ex) {
		ErrorMessage errorMessage = new ErrorMessage(ex.getMessage(), 404, "http://javabrains.koushik.org");
		return Response.status(Status.NOT_FOUND)
				.entity(errorMessage)
				.build();
	}
	

    //Providing generic exception handler class
    @Provider
    public class GenericExceptionMapper implements ExceptionMapper<Throwable> {

	@Override
	public Response toResponse(Throwable ex) {
		ErrorMessage errorMessage = new ErrorMessage(ex.getMessage(), 500, "http://javabrains.koushik.org");
		return Response.status(Status.INTERNAL_SERVER_ERROR)
				.entity(errorMessage)
				.build();
	} 